\documentclass{TDP019mall}
\usepackage{graphicx}
\usepackage{color,soul}
\usepackage{listings}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,
    urlcolor=cyan,
}
\graphicspath{{./bilder/}}


\newcommand{\version}{Version 1.0}
\author{Ahmed Sikh , \url{ahmsi881@student.liu.se}\\
Sayed Ismail Safwat, \url{saysa289@student.liu.se}}

\title{Språkdokumentation}
\date{\today}
\rhead{Ahmed Sikh\\
Sayed Ismail Safwat}


\begin{document}

\projectpage
\tableofcontents
\newpage
\section{Revisionshistorik}
\begin{table}[!h]
\begin{tabularx}{\linewidth}{|l|X|l|}
\hline
Ver. & Revisionsbeskrivning & Datum \\\hline
1.0 & Första version av Språkdokumentation & 210430 \\\hline
\end{tabularx}
\end{table}



\section{Inledning}
Detta är ett projekt på IP-programmet som är skapat under den andra terminen vid Linköpings universitet i kursen TDP019 Projekt: datorspråk.

\subsection{Syfte}
Syftet med denna kursen var att visa vilka komponenter ett språk består av och hur ett nytt programmeringsspråk byggs upp med de där komponenterna. 

\subsection{Introduktion}
I det här språket har tagits inspiration för det mesta från Ruby språket. ETL är utvecklats för en nybörjare användare och är skrivet i ett sätt som 
liknar skriftligt engelska vilket gör det möjligt för språkets läsbarhet.

\subsection{Målgrupp}
ETL (Easy To Learn) språket skall passa de nybörjare som har inga tidigare förkunskaper inom programmering. Det passar perfekt dem som vill börja lära 
sig programmering på rätt sätt som kommer täcka de mesta grunderna där en ny programmerare bör tänka på. Språket kommer även passa lärarna som vill lära
ut programmering till de nybörjare eller möjligtvis till en grupp av barn i grundskolan.


\section{Användarhandledning}

\subsection{Installation}
För att kunna testa ETL krävs den senaste versionen av Ruby installerad.

För att kunna köra språket krävs det laddas ner. Språket kan laddas ner via länken: 

\url{https://gitlab.liu.se/ahmsi881/tdp019/-/archive/master/tdp019-master.zip}

Användaren behöver skriva kommandoraden \textbf{\textit{ruby ETL.rb}} för att kunna köra programmet.

Det finns två sätt att köra ETL språket på:
\begin{enumerate}
    \item Att skriva kod genom terminalen, vilket är ett sätt om användaren vill skriva endast en enkel rad kod som inte består av flera saker samtidigt.
    Detta kan användaren göra i ETL.rb genom: se \textbf{Figur 1} i sektionen \textbf{Bilder}!.
    \item Andra sättet är att testa språket i sin helhet vilket innebär att användaren skriver sin kod i en fil som heter \textbf{etl.etl} där kommer 
    programmet ta hand om resten. Detta kan användaren göra i ETL.rb genom: se \textbf{Figur 2} i sektionen \textbf{Bilder}!.     
\end{enumerate}  

\newpage
\subsection{Variabler och Tilldelning}
Variabler har en dynamisk typning där användaren behöver inte specificera datatypen när den ska deklareras. Tilldelningen i ETL betecknas endast med 
tilldelningsoperatorn “=”. I ETL går det att tilldela en variabel till booleska värden, strängar och matematiska uttryck.

Det innebär att det ska finnas endast ett namn och dennes värde vilket visas i följande stil:
\begin{verbatim}
    x = 5 
    y = "Hej"
    z = "hej" plus "då"
    d = 5 < 10
\end{verbatim}


\subsection{Matematiska Operationer}
ETL kan utföra alla sedvanliga matematiska beräkningar såsom addition, subtraktion, multiplikation och division samt deras rätta prioriteter 
och associativiteten det vill säga division och multiplikation ska utföras före addition och subtraktion. Samtliga beräkningar utförs oavsett 
de är heltal eller flyttal. Språket stöder även beräkningarna inuti en parentes. Ex:

\begin{verbatim}
    (5 + 4)
    1 - 5
    2 * 1.0
    5 / 5
    4 - 7 * (10 / 2)
\end{verbatim}

Det går även att utföra matematiska beräkningar på variabler som har heltal eller flyttal som värde. Ex:
\begin{verbatim}
    x = 5
    y = x + 2
    z = x * y
\end{verbatim}

\subsection{Kommentarer}
I språket finns det möjligheten att ignorera en rad eller flera rader ifall användaren inte vill att de raderna ska köras. 
Detta görs genom att skriva \textbf{"< <"} för att ignorera en rad och för att ignorera fler rader måste det skrivas 
\textbf{"<comment"} i början av raden och \textbf{"<end"} i slutet av raden.

Exempel på flerradskommentar:
\begin{verbatim}
    <comment 
    Detta är en flerradskommentar och allt som skrivs i det här utrymmet kommer ignoreras och inte köras. 
    Som det syns här går det att skriva vad som helst. ?!”#€%&123456789
    Det är jätteviktigt att inte glömma skriva <end i slutet av raden.
    <end
\end{verbatim}
 
Exempel på enkelradskommentar:
\begin{verbatim}
    << Här ignoreras bara en rad som skrevs med << i början av raden.
    << Varje rad måste ha << i början för att den ska ignoreras.
\end{verbatim}
 
Kommenterar används ofta av programmerare som en påminnelse på hur dem har kommit fram till den specifika koden.

\subsection{Print}
I ETL går det att skriva ut datatyper som strängar, tal, logiska uttryck och flera strängar samtidigt förutsatt att de är tilldelade till en variabel innan utskriften. 
För att skriva ut används ordet \textbf{write} innan variabel namnet. 
Exempel: 
 
\begin{verbatim}
    a = “Printing should be easy!”
    write a
    ------------------------------
    b = 3 < 4
    write b
    ------------------------------
    c = 1234
    write c
\end{verbatim}
 
Skriver ut följande:

\begin{verbatim}
    -->> Printing ‘Printing should be easy!’
    ----------------------------------------
    -->> Printing ‘true’
    ----------------------------------------
    -->> Printing ‘1234’   
\end{verbatim} 


\subsection{Villkor/If-satser}
Att skriva villkor eller if-satser i ETL språket är inte avancerad. Användaren bör börja med \textbf{“if”} i början av raden, 
sedan öppna en parentes där kan användaren skriva en eller flera logiska uttryck som kan ge \textbf{falsk} eller \textbf{sant}, efter det stänger 
användaren parentesen och skriver därefter ordet \textbf{“then”}. Då börjar användaren på en ny rad för att skriva den satsen eller de satserna 
som ska utföras ifall de logiska uttrycken som finns inuti parentesen ska returnera \textbf{sant}. I slutet av en if-sats ska 
användaren skriva \textbf{“endif”} för att säga att här slutar villkoret.
 
Exempel på en if-sats: 
 
\begin{verbatim}
    x = 7
    y = 8
    if (x > 6 and y == 8) then
    write "if-sats är Sant"
    endif
\end{verbatim}

Skriver ut följande:
\begin{verbatim}
    -->> Printing ‘if-sats är Sant’
\end{verbatim}

\newpage
I ETL kan också användaren skriva en else-sats som följer efter en if sats. Detta kan användaren göra genom att skriva \textbf{“otherwise”} i 
en ny rad. Det betyder att om de logiska uttrycken som finns inuti parentes returnerar \textbf{falsk}, så kommer else satsen nu utföra den eller 
de satser som finns efter ordet \textbf{“otherwise”}. I slutet användare kommer också göra samma sak här det vill säga att skriva \textbf{“endif”} 
för att visa att här slutar villkoret.
 
Exempel på en if-sats som följer av en else-sats: 
\begin{verbatim}
    x = 7
    y = 8
    if (x less than 6 or y equal 9) then
    write "if-sats är Sant"
    otherwise
    write "otherwise-sats är Sant"
    endif
\end{verbatim} 

Skriver ut följande:
\begin{verbatim}
    -->> Printing ‘otherwise-sats är Sant’
\end{verbatim}

I ETL kan användaren bestämma skriva logiska operator i tecken, exempelvis: 

\textbf{<}, \textbf{>}, \textbf{<=}, \textbf{>=}, \textbf{!=} och \textbf{==} 

eller att skriva logiska operator i ord, exempelvis:

\textbf{less than}, \textbf{greater than}, \textbf{less than or equal to}, \textbf{greater than or equal to}, \textbf{not equal to} och \textbf{equal} 
\break 

ETL kan även hantera \textbf{or}, \textbf{and} och \textbf{not}, se exemplen ovan!

\subsection{Iteration}
Det finns en sort loop i ETL språket vilket kallas för en while-loop där användaren har möjlighet att iterera igenom exempelvis ett tal tills det villkoret i loopen har uppfyllts. 
För att skriva en while-loop skrivs först ordet \textbf{while} sedan villkoret inuti en parentes. Efter det går det att skriva den satsen eller de satserna när villkoret som finns inuti parentes uppfylls, därefter för att avsluta while-loopen måste ordet \textbf{endwhile} skrivas i en ny rad. 
Exempel: 
\begin{verbatim}
    y = 1
    while ( y < 4)
    write "while-loop fungerar"
    y = y + 1
    endwhile
\end{verbatim}
 
Skriver ut följande:
\begin{verbatim}
    -->> Printing 'while-loop fungerar'
    -->> Printing 'while-loop fungerar'
    -->> Printing 'while-loop fungerar'
\end{verbatim}
 
I exemplet ovan, skrevs ut \textbf{‘while-loop fungerar’} samt lägger till en etta till variabeln \textbf{y} så länge den 
uppfyller villkoret \textbf{(y < 4)}. Detta innebär att satserna kommer utföras tills det variabeln \textbf{y} är mindre än fyra. 
 
I ETL går det även att avbryta while-loopen genom att skriva \textbf{stop} efter de satserna som ska utföras för det första gången. 
Detta gör while-loopen att utföra de satserna endast en gång, därefter kommer det avbrytas.
\newpage
Exempel: 
\begin{verbatim}
    y = 1
    while ( y < 4)
    write "while-loop fungerar endast en gång"
    y = y + 1
    stop
    endwhile
\end{verbatim}
 
Skriver ut följande:
\begin{verbatim}
    -->> Printing 'while-loop fungerar endast en gång'
\end{verbatim}


\subsection{Funktioner}
ETL språket har två sorts funktioner:
\begin{enumerate}
\item Funktioner utan parametrar:

För att definiera en funktion utan parameter i ETL behöver användaren skriva \textbf{define} sedan sätta ett namn på den funktionen. 
Därefter måste användaren skriva töm parentes så att kodraden kommer se ut så här: \textbf{define name()} i slutändan.
 
Efter definitionen av funktionen kan användaren skriva en eller flera satser inuti funktionskroppen. Funktionskroppen avslutas med 
ordet \textbf{return} beroende på vad användaren vill returnera.
 
I slutet bör alltid användaren skriva ordet \textbf{enddef} för att avsluta funktionskroppen. 
 
Användaren kan anropa funktionen genom att skriva exempelvis \textbf{write name()} på en ny rad, där kommer terminalen skriva 
ut det som funktionen returnerar.  
 
Exempel på funktioner utan parameter:
\begin{verbatim}
    define add()
    a = 4
    b = 5
    c = a + b
    return c
    enddef

    write add()
\end{verbatim}
 
Skriver ut följande:
\begin{verbatim}
    -->> Function 'add' returning '9'
\end{verbatim}

 
\item Funktioner med parametrar:

För att definiera en funktion med parametrar i ETL behöver användaren skriva \textbf{define} sedan sätta ett namn på den funktionen. 
Därefter måste användaren öppna en parentes för att skriva parameters namn. Funktionen kan ta flera parametrar som har kommatecken emellan. 
Kodraden kommer se ut så här: \textbf{define name(a ,b)} i slutändan.
 
Efter definitionen av funktionen kan användaren skriva en eller flera satser inuti funktionskroppen. Funktionskroppen avslutas med 
ordet \textbf{return} beroende på vad användaren vill returnera.
 
I slutet bör alltid användaren skriva ordet \textbf{enddef} för att avsluta funktionskroppen. 
 
Användaren kan anropa funktionen med parametrar genom att skriva exempelvis \textbf{write name(2, 5)} på en ny rad, där parametrarna 
som finns inuti parentesen ska ta sina värde. I slutet kommer terminalen skriva ut det som funktionen returnerar.  
 
 
Exempel på funktioner med parameter:
\begin{verbatim}
    define add(a, b)
    s = a + b
    return s
    enddef

    write add(25, 75)
\end{verbatim}
Skriver ut följande:
\begin{verbatim}
    -->> Function 'add' returning '100'
\end{verbatim}
\end{enumerate}



\subsection{Multiple Strings}
ETL har en konstruktion som heter Multiple Strings. Denna finns för att låta användaren att addera två eller flera strängar med 
varandra genom att skriva ordet \textbf{plus} mellan de strängarna som ska adderas.
Exempel: 
\begin{verbatim}
    x = “ETL” plus “ är enkelt.”
    write x
    ------------------------------------
    y = "ETL"
    z = " är lätt"
    write y plus z plus " att lära sig."
\end{verbatim}
 
Skriver ut följande:
\begin{verbatim}
    -->> Printing 'ETL är enkelt.'
    -----------------------------------------
    -->> Printing 'ETL är lätt att lära sig.'
\end{verbatim}



\newpage
\section{Systemdokumentation}
ETL språket uppbyggt på \textbf{rdparse.rb} som är tagen från båda TDP007 och TDP019 kurshemsidan. \textbf{rdparse.rb} hjälper med att göra den lexikaliska 
analysen samt själva parsning delen på den koden som användaren skriver. 

\textbf{ETL.rb} och \textbf{classes.rb} filerna är skapade av oss senare under projektarbetet. Filen classes.rb består av alla noder 
som används i match reglerna i ETL.rb där alla reglerna som bestämmer syntaxen är skriven i.  


\subsection{Lexikaliska Analys}
I lexikaliska analysen skapas de olika tokens som språket har i \textbf{ETL.rb}. Tokens består av reguljära uttryck(RegEx) som är en följd av 
flera tecken som matchar en viss mönster. 

I slutet kommer alla tokens skickas vidare till parsen. 

Här kommer alla tokens i samma ordning som de är på \textbf{ETL.rb} filen:

\begin{enumerate}

\item \textbf{Tokens som inte ska parsas och kommer ignoreras:}
\begin{itemize}

\item Matchar och ignorerar flerradskommentarer.
\begin{verbatim}
    token(/\<comment[^!]*\<end/)
\end{verbatim}
\item Matchar och ignorerar enkelradskommentar
\begin{verbatim}
    token(/(<<.+$)/)
\end{verbatim}
\item Matchar och ignorerar alla mellanrum
\begin{verbatim}
    token(/\s+/)
\end{verbatim}
\end{itemize}

\item \textbf{Tokens som ska parsas:}
\begin{itemize}
\item Matchar alla flyttal och returneras som "Float"
\begin{verbatim}
    token(/(\d+[.]\d+)/) { |m| m.to_f }
\end{verbatim}
\item Matchar alla heltal och returneras som "Integer"
\begin{verbatim}
    token(/\d+/) { |m| m.to_i }
\end{verbatim}
\item Matchar strängar inom enkelcitattecken
\begin{verbatim}
    token(/'[^\']*'/) { |m| m } 
\end{verbatim}
\item Matchar strängar inom dubbeltcitattecken
\begin{verbatim}
    token(/"[^\"]*"/) { |m| m }
\end{verbatim}
\item Matchar namn på variabler
\begin{verbatim}
    token(/[a-z]+[a-z0-9_]*/) { |m| m }
\end{verbatim}
\item Matchar allt annat(enkla käraktarer)
\begin{verbatim}
    token(/./) { |m| m } 
\end{verbatim}
\end{itemize}
\end{enumerate}

\newpage
\subsection{Parsning}
Efter att alla tokens har skickats från lexikaliska delen för parsning, och matchats de reglerna som beskriven i vår 
BNF-grammatiken då börjar parsern gör sitt jobb som är att hitta det mönstret från det koden som användaren skriver och bygga abstrakta 
syntaxträdet i slutet. Parsern körs rekursivt och går efter BNF-grammatiken. 

Varje konstruktion i ETL språket har sin egen klass vilket varje klass har en \textbf{eval()} funktion som körs när programmet använder
 den relevanta klassen och dennes eval funktion. 
 
Exempel: (Se \textbf{Figur 3} i sektionen \textbf{Bilder}!)


\subsection{Kodstandard}
Språket använder sig inte av något indentering vilket innebär att alla mellanrum kommer tas bort från koden som användaren skriver. 

Vissa kodstandard som \textbf{ETL} har:
\begin{itemize}
\item I slutet av varje \textbf{if-sats} måste användaren avstänga kroppen genom att skriva \textbf{endif}.
\item Efter varje if-statement måste användaren skriva \textbf{then}.
\item I slutet av varje \textbf{while-loop} måste användaren avstänga kroppen genom att skriva \textbf{endwhile}.
\item I slutet av varje \textbf{funktion} måste användaren avstänga kroppen genom att skriva \textbf{enddef}.
\item Booleska uttryck kan skrivas antingen i numeriskt eller skriftligt sätt. Exempel: \textbf{<} eller \textbf{less than} osv.
\end{itemize}


\section{Reflektion}
kanske med scopehantering (vi får se)


\section{BNF Grammatik}
\lstinputlisting[language=Ruby]{BNF.txt}


\newpage
\section{Bilder}

\begin{figure}[h]
\caption{Exempel på hur ska det se ut när användaren vill testa språket genom terminalen}
\centering
\includegraphics[width=\textwidth]{activate_terminal}
\end{figure}

\begin{figure}[h]
\caption{Exempel på hur ska det se ut när användaren vill testa språket genom en test fil}
\centering
\includegraphics[width=\textwidth]{activate_file}
\end{figure}

\newpage
\begin{figure}[h]
\caption{Här parsas en konstruktion där flera strängar adderas med varandra med hjälp av klass objektet som skapas av klassen \textbf{Plus\_str}.\\ \\}
\centering
\includegraphics[width=110mm]{tree}
\end{figure}
    

\end{document}